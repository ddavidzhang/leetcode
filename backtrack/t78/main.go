package main

import "fmt"

/*
 * @lc app=leetcode.cn id=78 lang=golang
 * 要点：回溯法，每个元素都有两种状态，选或者不选，选了就加入结果集，不选就跳过
*  注意 slice 的 append 操作，会改变原 slice 的值，所以要用一个临时变量保存当前的结果
*/
func subsets(nums []int) [][]int {
	res := make([][]int, 0)
	var dfs func(nums, r []int, i int)
	dfs = func(nums, r []int, i int) {
		if i == len(nums) {
			t := make([]int, len(r))
			copy(t, r)
			res = append(res, t)
			return
		}
		dfs(nums, r, i+1)
		dfs(nums, append(r, nums[i]), i+1)
	}
	dfs(nums, []int{}, 0)
	return res
}

func main() {
	fmt.Println(subsets([]int{9, 0, 3, 5, 7}))
	fmt.Println(len(subsets([]int{9, 0, 3, 5, 7})))
}

// 错误的输出
// [[],[7],[5],[5,7],[3],[3,7],[3,5],[3,5,7],[0],[0,7],[0,5],[0,5,7],[0,3],[0,3,7],[0,3,5],[0,3,5,7],[9],[9,7],[9,5],
// [9,5,7],[9,3],[9,3,7],[9,3,5],[9,3,5,7],[9,0],[9,0,7],[9,0,5],[9,0,5,7],[9,0,3],[9,0,3,5],[9,0,3,5],[9,0,3,5,7]]
// 正确的输出
// [[],[9],[0],[0,9],[3],[3,9],[0,3],[0,3,9],[5],[5,9],[0,5],[0,5,9],[3,5],[3,5,9],[0,3,5],[0,3,5,9],[7],[7,9],[0,7],
// [0,7,9],[3,7],[3,7,9],[0,3,7],[0,3,7,9],[5,7],[5,7,9],[0,5,7],[0,5,7,9],[3,5,7],[3,5,7,9],[0,3,5,7],[0,3,5,7,9]]
